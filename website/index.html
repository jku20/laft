<!DOCTYPE html>

<!-- In the below script block, write markdown and it will be rendered on the page. -->
<script id="markdown_text" type='text/markdown'>
<hr>
  # Introduction
<hr>
<marquee class="quote">Why spend $500 on lab equipment when you can build it for the price of a Big Mac?</marquee>



**Project:** LAFT is a 16-channel logic analyzer built with the RP2350 microcontroller capable of sampling
signals up to 100 MHz. The analyzer uses the Pico 2 PIO state machine to capture the logic values of 16
GPIO pins simultaneously on every microcontroller CLK cycle. We also designed a custom PCB for the device
with 8-channel header pins on each side. Furthermore, each channel connects to one of two level-shifters,
which convert an input logic level between 1.8 and 5V to the 3.3V required by the RP2350. Our logic analyzer
is compatible with the open-source SUMP protocol, so tools such as PulseView can be used with LAFT. 

**Motivation:** Traditional electrical measurement tools are a significant cost for any electrical lab.
Complex logic analyzers typically cost hundreds to thousands of dollars. Assuming bulk part orders, we
are building a functional analyzer for just ~$10. This device would be one or two orders of magnitude
cheaper than consumer options, acting as a powerful, cost-effective alternative that is easily replicable.
The inclusion of the SUMP interface will make it extremely simple to gather data with the logic analyzer and
port it over to another to PulseView for visualization purposes. 


<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
# High-Level Design
<hr>

Jeremy plans on making a controller adapter in the near future. To that end a logic analyzer is extremely useful for
debugging erronious logic too and from the adapter as well as figuring out poorly documented protocols. The wires he is
using range from 3.3v to 5v. Commercial solutions are generally fairly expensive, in the $50 to $1500 range.

However, there are many open logic analyzer projects. One we drew much inspiration from was
[ula](https://github.com/dotcypress/ula), a logic analyzer for the rp2040 partially implementing the SUMP protocol. It
was made to be used with [PulseView](https://sigrok.org/wiki/PulseView) which we also attempted to support via similar
means. We additionally wrote our own GUI in addition to PulseView which took inspiration from
[can-explorer](https://github.com/Tbruno25/can-explorer) which connected to the logic analyzer flashed with different
software built as a vendor specific USB device communicating with our own protocol. We are not aware of other projects
built on Rasberry Pis which do something similar.

There are three parts to the software of this project. For our Pico 2, we created firmware to let the device be used as
a vendor specific USB device, software to connect to the logic analyzer when using this firmware, and firmware to let
the device connect over the serial port to the PulseView logic analyzer software using the
[SUMP protocol](https://sump.org/projects/analyzer/protocol/).

<hr>
# Hardware Design
<hr>

In order to create a logic analyzer that could accommodate a wide range of digital input signals, three main goals had to be met on the hardware end:
<ul>
- **Requirement 1:** The design needs to be able to accommodate the voltage levels of many common protocols (e.g. 1.8V, 3.3V, 5V) and translate them to 3.3V logic that can be safely input to the RP2350.
- **Requirement 2:** It should be possible to feed in signals on 8+ channels, and the corresponding GPIO pins should be easily accessible.
- **Requirement 3:** The hardware should ideally be able to sample high-frequency signals up to around 100 MHz.
</ul>

To meet all of the above goals, we opted to design a PCB in Altium. The board acts as a 
standalone interface for interacting with the logic analyzer; it contains two 16-pin 
headers, each of which accommodates 8 high-speed digital signals from 1.8V to 5V, GND 
connections, and a signal indicating the voltage level (VCCB). One header feeds into level 
shifter 1 (LS1), which will translate the digital inputs to 3.3V (VCCA) and pass those to 
GPIO8 through GPIO15. The other header feeds into level shifter 2 (LS2), which does the same 
but for GPIO16 through GPIO22 (as well as GPIO26). 

Both level shifters can be enabled by driving GPIO5 and GPIO28 (the designated output-enable 
pins on the RP2350) low. While these level shifters can function bidirectionally, the 
direction (DIR) pins are hardwired to GND using pull-down resistors, strictly enforcing 
voltage translation from the headers pins towards the RP2350.

<div class="row">
  <div class="column">
    <figure>
      <img src="logicanalyzer-layout3D.png" alt="layout3D" style="max-width: 118%; height: auto; display:block; margin:auto;">
      <figcaption>3D view of logic analyzer PCB</figcaption>
    </figure>
  </div>
  <div class="column">
    <figure>
      <img src="logicanalyzer-layout2D.png" alt="layout2D" style="max-width: 120%; height: auto; display:block; margin:auto;">
      <figcaption>Layout of logic analyzer PCB</figcaption>
    </figure>
  </div>
</div> 

<br>

<figure>
  <img src="logicanalyzer-fullschematic.png" alt="fullschematic" style="max-width: 100%; height: auto; display:block; margin:auto;">
  <figcaption>Full schematic of logic analyzer PCB (for higher resolution screenshots, see Appendix C)</figcaption>
</figure>

The level shifters present on our PCB easily accommodate a number of common logic levels 
and are able to pass signals up to 100 MHz, allowing us to emulate the behavior of benchtop 
logic analyzers at a fraction of the cost. Signal integrity is not a major issue here even 
at high-speed, since we were particular about controlling trace width and keeping trace 
lengths to a minimum. Other parts our PCB, like the UART debug header, optional external 
power circuitry, and reset button are other convenience features that further expand 
functionality for the user.

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
# Program Design
<hr>
We will enumerate the three separate software projects composing our logic analyzer. We start with the firmware and
software connecting as a vendor specific USB device and then follow with the firmware connecting as a virtual serial
port to PulseView.

## USB Logic Analyzer
The firmware does not depend on any third party libraries, such as TinyUSB, when interfacing with the USB periferal,
however, it uses siginficant code from the [dev lowlevel](https://github.com/raspberrypi/pico-examples/tree/4c3a3dc0196dd426fddd709616d0da984e027bab/usb/device/dev_lowlevel)
example for listening and responding to transfers from the USB host. Concretely, use logic from the example to receive
transfers from the host and then call a handler. Our responses are composed of multiple transfers so we wrote a request
queue. This is implemented as a fixed sized FIFO built around a circular buffer. When the logic analyzer needs to send
a sequence of responses, it queues each of these respones in the request queue, starting the first response in the
request queue. Once that response is sent, the program calls a handler which checks if the queue is empty. If it isn't,
the program will send the next request. This repeats until the queue is empty.

The data sent over the USB uses a protocol we created. It is incomplete as we abandoned it to instead use SUMP as
described below. The description of the incomplete protocol follows:

### Protocol Overview
The laft usb application must communicate with the logic analyzer. They do it with the following protocol sent through
USB bulk transfers. The laft application, a usb host, sends requests and the logic analyzer, a usb device, sends
responses. There is no channel for the logic analyzer to make requests of its host. Each request is a 64 bit packet
**starting with a 1 byte opcode**. The rest of request varies between opcodes. The format and size of a response depends
on it's corresponding request. 

### Protocol Opcodes
#### Trace Request
**Request**: |01|XX|SSSS|XXXXXXXX|

This request is used to dump data from every trace attached to the logic analyzer. A trace request starts with a 1 byte
opcode, 0x01. It then follows with a 2 bytes of don't care. It then is a 2 byte little endian integer, the number of
*bits* of data being requested *from each trace*. It then ends with 4 don't care bytes.

**Response**: The response will be a series of 8 byte responses, the raw data form each trace. Bits from each every
trace are packaged into 2 bytes (traces indexed lower being first) and then this packed data is sequenced. It is
sent over 64 bit responses. The final response may be incomplete, in which case the final bytes will be don't cares.

#### Frequency Set Request
**Request**: |02|XXXXXX|FFFFFFFF|

This request sets the frequency the logic analyzer will expect from its traces. A frequency set request starts with a 1
byte opcode, 0x01. It then followed with 3 bytes of don't cares and ends with a 4 byte little endian integer, the
frequency to listen at.

**Response**: The MCU is not expected to respond to this request.

#### Rising Edge Trigger Request
**Request**: |04|X|P|SSSS|XXXXXXXX|

This request request is used to dump data from every trace attached to the logic analyzer starting on a rising edge for
a pin specified by P. This is similar to a trace request, but instead of starting recording at some arbitrary point in
time, it starts on a rising edge. The format is composed of a one byte opcode, followed by a nibble of don't cares and
then a 4 bit number, the pin of the logic analyzer to look for an edge on. This is followed by a little endian two byte
size, the number of bits to record *from each trace*. The request is then padded by four bytes of don't cares.

**Response**: The response is a series of 8 byte responses, the raw data from each trace. It's format is the same as a
Trace Request. Refer there for more details.

### Implementation Notes
The most difficult piece of this protocol to implement was rising edge trigger requests. The frequency set request
could be implemented by setting the PIO state machine clock divider, and the trace request was simply an easier version
of the rising edge trigger request.

To implement the rising edge trigger request, we use PIO state machines to read in values from the GPIO pins. This lets
the logic analyzer perform reads during every cycle, thus letting it scan on the order of a 100MHz. We hard code
recognition for rising edges.
```
top:
  jmp pin, top
  jmp pin, read
  jmp top
read:
.wrap_target
  in pins, 16
.wrap
```
The program allows reads every cycle, but misses one cycle of reads when looking for the rising edge. This makes it
possible for the logic analyzer to "miss" a rising edge if that rising edge occurs the cycle the program jumps back to
the top of the rising edge detection code. Fortunatley, this is only likely to happen if the trace the logic analyzer
is measuring changes at a frequency approaching the logic analyzers scanning speed and the tracing being measured is
aperiodic (as otherwise even if the logic analyzer misses one edge, it will probably detect the next one). This was a
reasonable limitation for us.

Once the PIO state machine goes into a loop reading data, a DMA channel will get data requests to move data to an
output buffer. When the amount of request data fills the buffer, the DMA channel ceases transfering data and the state
machine is stopped. The data from the buffer is then queue to be sent to the host.

### Logic Analyzer GUI
We created a GUI for our logic analyzer in Python using [DearPyGui](https://github.com/hoffstadt/DearPyGui) and
[pyusb](https://github.com/pyusb/pyusb). The GUI's main purpose is for live monitoring the logic analyzer's traces.
The GUI starts a render thread and a polling thread. The render thread draws the current buffer to the screen every
frame and handles user interaction. The polling thread periodically sends trace requests to the logic analyzer and
updates the render thread's data with the responses.

< Add some image here of the ui>

The UI is simple. Due to time constraints, it doesn't support trigger requests or fancy analysis of the waveforms.
However, the live display alone was quite helpful and we found ourselves reaching first to this prototype when
debugging our other firmware (described below).

## SUMP Logic Analyzer
After writing the GUI above, we noticed there exists open logic analyzer software we could attempt to support, namely,
PulseView, part of the larger (sigrok)[https://sigrok.org] project. PulseView supports many different logical analyzer
protocols, but we chose to partially implement the SUMP protocol due to its simplicitly. In our discussion of SUMP we
will omit details we do not implement or not relevant to our discussion. This would be a good place to link to a proper
description of the protocol, but I am not aware on one which exists. The original spec is ill defined, and most sources
I found simply copy the original spec word for word. 

SUMP is built around triggers. The logic analyzer software first sends the logic analyzer up to four pairs of 32 bit
bitstrings. Each pair is composed of a trigger mask and a trigger value. SUMP has two modes, serial mode and parallel
mode, of which we support parallel mode. In parallel mode, when the logic analyzer is armed, it tries to match each
pair of trigger value and mask in order. To match a pair, each trace is read at the same time. The ith trace is
compared to the ith bit in the trigger value. If they compare equal or the ith bit of the trigger mask is zero, the
bits are said to match, else they do not match. If every trace matches every trigger value, then the next pair of
trigger value and trigger mask attempts to be matched against. Otherwise, the program must try and match the current
pair again (it does not forget about previous matched pairs). Once all pairs are matched, the logic analyzer will begin
reading the number of samples requested of it.

The most difficult part of implementing this is supporting the variable trigger conditions while maintaining speed when
reading from the traces. To do this, we
[base our implementation on ula's trigger logic](https://github.com/dotcypress/ula/blob/40756c4199c9f2ac605a39bfed2eddcc7fe0324b/src/trigger.rs),
a Rust implementation of a SUMP based logic analyzer. In particular, we generate PIO programs at runtime based on the
trigger masks and trigger values received from the logic analyzer software. 
```
for (int i = 0; i < NUM_STAGES; i++) {
  int stage_offset = static_pc;
  if (bitset_is_empty(&trigger_mask[i])) {
    continue;
  }

  uint32_t mask = bitset_get_raw(&trigger_mask[i]);
  uint32_t value = bitset_get_raw(&trigger_value[i]);

  prog[static_pc++] = pio_encode_mov_reverse(pio_osr, pio_pins);
  while (mask) {
    int mask_zeros = trailing_zeros(mask);
    if (mask_zeros) {
      prog[static_pc++] = pio_encode_out(pio_null, mask_zeros);
      mask >>= mask_zeros;
      value >>= mask_zeros;
    }
    int mask_ones = MIN(trailing_ones(mask), 5);
    if (mask_ones) {
      prog[static_pc++] = pio_encode_out(pio_x, mask_ones);
      prog[static_pc++] =
          pio_encode_set(pio_y, value & ((1 << mask_ones) - 1));
      prog[static_pc++] = pio_encode_jmp_x_ne_y(stage_offset);
      mask >>= mask_ones;
      value >>= mask_ones;
    }
  }
}

prog[static_pc++] = pio_encode_in(pio_pins, 16);
```
We generate one PIO program from all four value mask pairs. Each pair gets a section of the program which starts with a
read, then checks the read bits, and then either branches back to the initial read or falls through to the next section
for the program. Concretely, each section starts with a `mov` instruction from the pins to the output status register.
The program then differs based on the mask. For every zero in the mask, the program inserts an `out` instruction
shifting one bit from the pin read stored in the osr into null. For every one in the mask, the program uses an `out`
instruction to shift a one bit into the x scratch register. It then uses a `set` intruction to set the y scratch
register to the corresponding bit of the trigger value. If these bits compare equal, the program falls through to
the next comparison, else it jumps to to the begining of that pair's section. If there are no more comparison, the
program falls through to the next pair's section or simply to the loop reading data from the pins to the isr.

This technique has a few pitfalls. It takes a variable number of cycles to do each trigger check, and the amount of
cycles it takes to perform a trigger check is significantly longer than the cycles it takes to read from the pins.
The means some data is lost from between when the trigger matches the trace data and when the logic analyzer begins to
poll the traces. We found this to be visible when polling high frequency signals. We believe this is a fundemental
limitation of using the PIO state machines as they cannot perform large bitwise operations letting us account for the
trigger mask. In addition, it's possible for the generated PIO programs to exceed the 32 instructions. We similarly
do not have a solution and believe this too is a fudamental limitation of attempting to use a single PIO state machine.
Using multiple state machines additionally doesn't work because they would have to communicate in a cycle precise level
to maintain the speed we have. It may be possible to get close using a DMA channels to transfer bits between the state
machines' FIFOs, but this doesn't have the same consistant, precise timing guarentee that having the program on a
single PIO state machine gives, exasterbating the first problem.

Overall, though, we found this technique functional and the only way we found or could think of to conform to SUMP.
The evaluation above suggests it may simply be SUMP is too complex a protocol to be able to effectively support on the
rp2350's state machines.

<hr>
# Results
<hr>

< put stuff here, see course page: https://vanhunteradams.com/Pico/CourseMaterials/Final_Project.html#Final-Report >

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
# Conclusion
<hr>

Our design met some expectations and failed others. At a base level, it works as a logic analyzer and can read data
from high frequency traces using both PulseView and our own GUI. However, we found, as we explain below and above, SUMP
does not seem to be a protocol well fit for logic analyzers built with the rp2350. This and bugs in our software and,
we suspect PulseView, make the user experience poor. The user experience in our GUI is much better, though it is
limited by the GUI itself. In retrospect spending more effort there instead of rewriting our software to support SUMP
would likely have created a much better user experience.

< add more to the conclusion >

### Obstacles Faced In Development
AAA
<ul>
- **Hardware Problems**
  <ul>
  - **Short Circuits and Faulty Power-Up:** at some point during the development process, one of the level shifters that was soldered to our PCB experienced internal damage; when 5V signals were then fed into the input pins and the corresponding rail was driven to 5V, lots of odd behavior ensued. The output-enable pin was forced high despite the Pico actively trying to drive the pin low, preventing any signals from being level shifted. Furthermore, the 3.3V rail (connected directly to the Pico) was forced above 4V. This eventually resulted in the Pico failing to power up, breaking all flashing functionality and forcing our team to solder an entirely new PCB.
  - **Fabrication Issues:** when first ordering our boards, we encountered fabrication issues having to do with the open-source Altium footprints we took from Ultra Librarian online. The level shifters in particular had a number of problems with solder pads. On top of the pads for each pin missing soldermask (which caused a hold-up in fabrication on the order of several days), the footprint also contained "ghost pads" which should have never been placed on the board. These were not caught until after boards came in, although these did not prove to be much of an issue as long as caution was taken while soldering.
  </ul>
<br>
<figure>
  <img src="logicanalyzer-faultypad.png" alt="fabrication issue" style="max-width: 40%; height: auto; display:block; margin:auto;">
  <figcaption>Example of a fabrication issue w/ floating pads</figcaption>
</figure>
<br>
- **Software Problems**
  <ul>
  - **SUMP an Unclear and Unfit Specification**: The specification for SUMP is poor which requird us to read other projects using SUMP and experiment to figure out the specification. After figuring out this specification, we realized some features are difficult to implement fully on the rp2350 and a different protocol may be better suited for the project.
  - **Inconsitant PIO State Machines**: PIO state machines will sometimes stall waiting for triggers when run multiple times. We have no idea why and no theory to make progress with.
  - **PulseView Dropping Packets**: We believe PulseView occasionally drops packets causing out sent over data to be corrupted. We found data corruption consistent with this hypothesis when testing with PulseView but could never reproduce similar issues when testing combinations of requestss using our own test script.
  </ul>
</ul>

<br>
<br>
<br>
  
### Intellectual Property Considerations
< put stuff here, see course page: https://vanhunteradams.com/Pico/CourseMaterials/Final_Project.html#Final-Report>

<br>
<br>
<br>

### Further Improvements
< put stuff here, see course page: https://vanhunteradams.com/Pico/CourseMaterials/Final_Project.html#Final-Report>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

# Appendix
<hr>
### Appendix A - Permissions
<hr>

**Project on Course Page:** The group approves this report for inclusion on the course website.
<br>
**Project on YouTube:** The group did not record a video for inclusion on the course youtube channel.

<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
### Appendix B - Code
<hr>

< insert commented C code here >

<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
### Appendix C - Schematics
<hr>

<figure>
  <img src="logicanalyzer-fullschematic.png" alt="fullschematic" style="max-width: 80%; height: auto; display:block; margin:auto;">
  <figcaption>Full schematic of logic analyzer PCB</figcaption>
</figure>

<br>

<figure>
  <img src="logicanalyzer-RP2350.png" alt="RP2350 circuit" style="max-width: 70%; height: auto; display:block; margin:auto;">
  <figcaption>RP2350 connections for the logic analyzer</figcaption>
</figure>

<br>

<figure>
  <img src="logicanalyzer-levelshifters.png" alt="Level shifter circuit" style="max-width: 70%; height: auto; display:block; margin:auto;">
  <figcaption>Level shifter circuit for the logic analyzer</figcaption>
</figure>

<br>

<figure>
  <img src="logicanalyzer-headers.png" alt="Header circuit" style="max-width: 70%; height: auto; display:block; margin:auto;">
  <figcaption>Headers on the PCB</figcaption>
</figure>

<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
### Appendix D - Task Distribution
<hr>

<ul>
- **Colin Muessig** (cjm369)
  <ul>
  - Designed the PCB used for our logic analyzer in Altium
  - Soldered PCB and debugged faulty behavior; validated logic analyzer at the hardware level (level shifter operation, passage of signals, etc.)
  </ul>
  <br>
  - **Jeremy Ku-Benjet** (jk2582)
  <ul> 
  - < Put work tasks here > 
  </ul>
  <br>
- **Matthew Hurford** (mlh348)
  <ul>
  - < Put work tasks here>
  </ul>
</ul>

<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
### Appendix E - References
<hr>

<ul>
- **Datasheets**
  <ul>
  - [Raspberry Pi Pico 2 Datasheet](https://datasheets.raspberrypi.com/pico/pico-2-datasheet.pdf)
  - [Level Shifter Datasheet](https://www.ti.com/lit/ds/symlink/sn74lvc8t245.pdf?ts=1765867829527)
  </ul>
  <br>
  - **Code / Designs Borrowed From Others**
  <ul>
  - [Level Shifter Altium Footprint](https://app.ultralibrarian.com/details/165e9ff7-103f-11e9-ab3a-0a3560a4cccc/Texas-Instruments/SN74LVC8T245DBR?uid=668960&exports=41&open=exports)
  - [Raspberry Pi Pico 2 Altium Footprint](https://github.com/amgsus/RPi-Pico-Altium)
  - [16-Pin Header Altium Footprint](https://app.ultralibrarian.com/details/edb9d735-103e-11e9-ab3a-0a3560a4cccc/TE-Connectivity/5102153-3?uid=39437029)
  - [3-Pin Header Altium Footprint](https://app.ultralibrarian.com/details/425a797b-1081-11e9-ab3a-0a3560a4cccc/Samtec-Inc/TSW-103-15-T-S?uid=12085636)
  - [2-Pin Header Altium Footprint](https://app.ultralibrarian.com/details/42530aaf-1081-11e9-ab3a-0a3560a4cccc/Samtec-Inc/TSW-102-06-S-S?uid=271997)
  </ul>
  <br>
- **Background Sites / Papers**
  <ul>
  - < insert any relevant links here >
  </ul>
  <br>
</ul>

<br>
<br>
<br>

</script>

<head>
    <link rel="stylesheet" href="template.css" type="text/css">
    <link rel="icon" href="favicon.ico">
</head>
<body>
    </div>
    <div id="main">
        <div id="title_block">
          <h1>LAFT Logic Analyzer</h1>
          <h2>ECE 4760/5730 Final Project</h2>
          <br>
          <div class="subtitle">
            Colin Muessig (cjm369) · Jeremy Ku-Benjet (jk2582) · Matthew Hurford (mlh348)
          </div>
          <br>
          <figure>
            <img src="BuddyCombo.png" id="buddycombo" alt="Project mascot (dog)" style="max-width: 70%; height: auto; display:block; margin:auto;">
          </figure>
          <figcaption class="photo_caption">Buddy — Chief Debugging Officer</figcaption>
    </div>
        <fieldset id="markdown">
        </fieldset>
    </div>
</body>
<script>
markdown_text = document.getElementById("markdown_text").textContent

//   MIT License
// 
// Copyright (c) 2025 Fgaoxing
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
class MiniGFM{constructor(t){this.options=t||{}}parse(t){if("string"!=typeof t)return"";let s=[],n=[];return t=this.t(this.i(t.replace(/(?:^|\n)[^\\]?(`{3,4})[ ]*(\w*?)\n([\s\S]*?)\n\1/g,(t,e,r,n)=>(s.push({lang:r.trim(),code:n.trim()}),`<!----CODEBLOCK${s.length-1}---->`)).replace(/([^\\])`([^`]+)`/g,(t,e,r)=>(n.push(this.l(r)),`${e}<!----CODEINLINE${n.length-1}---->`)).replace(/\\([\\*_{}[\]()#+\-.!`])/g,(t,e)=>"&#"+e.charCodeAt(0)).replace(/%%[\n ][^%]+[\n ]%%/g,""))).replace(/<!----CODEINLINE(\d+)---->/g,(t,e)=>n[e]?`<code>${n[e]}</code>`:"").replace(/<!----CODEBLOCK(\d+)---->/g,(t,e)=>{if(!s[e])return"";var{lang:e,code:r}=s[e];let n=r;if(this.options.hljs)try{n=(e?this.options.hljs.highlight(r,{language:e}):this.options.hljs.highlightAuto(r)).value}catch{}return e?`<pre lang="${e}"><code class="hljs ${e} lang-${e}">${n}</code></pre>`:`<pre><code>${n}</code></pre>`}),this.options.unsafe?t:this.$(t)}i(t){return t.replace(/^[^\\]?\s*(#{1,6}) ([^\n]+)$/gm,(t,e,r)=>`<h${e.length}>${r}</h${e.length}>`).replace(/^[ \t]*[-\*\+][ \t]+\[([ ]*[ xX]?)\]\s([^\n]+)$/gm,(t,e,r)=>`<li><input type="checkbox" ${"x"===e.trim().toLowerCase()?"checked":""} disabled> ${r}</li>`).replace(/^[ \t]*[-\*\+] ([^\n]+)$/gm,"<li>$1</li>").replace(/^[ \t]*(\d+\.) ([^\n]+)$/gm,"<li>$1 $2</li>").replace(/^ {0,3}(([*_-])( *\2 *){2,})(?:\s*$|$)/gm,()=>"<hr/>").replace(/^[ \t]*((?:\>[ \t]*)+)([^\n]*)$/gm,(t,e,r)=>{e=e.length/2;return""===r.trim()?"":"<blockquote>".repeat(e)+r+"</blockquote>".repeat(e)}).replace(/^([^\n]*\|[^\n]*)\n([-:| ]+\|)+[-\| ]*\n((?:[^\n]*\|[^\n]*(?:\n|$))*)/gm,(t,e,r,n)=>this.g(e,r,n)).split(/\n{2,}|\\\n/g).map(t=>/^<(\w+)/.test(t)?t:`<p>${t}</p>`).join("<br />")}g(t,e,r){let n=t.split("|").map(t=>t.trim()).filter(Boolean),s=this.o(e);t=r.trim().split("\n").reduce((t,e)=>{if(e.includes("|")){let r=e.split("|").slice(1,-1).map(t=>t.trim());t.push(n.map((t,e)=>r[e]||""))}return t},[]);let a=["<table>","<thead><tr>"];return n.forEach((t,e)=>{a.push(`<th${s[e]?` align="${s[e]}"`:""}>${t}</th>`)}),a.push("</tr></thead>"),t.length&&(a.push("<tbody>"),t.forEach(t=>{a.push("<tr>",...t.map((t,e)=>`<td${s[e]?` align="${s[e]}"`:""}>${t}</td>`),"</tr>")}),a.push("</tbody>")),[...a,"</table>"].join("")}o(t){return t.split("|").map(t=>t.trim()).filter(Boolean).map(t=>{var e=t.startsWith(":"),t=t.endsWith(":");return e&&t?"center":e?"left":t?"right":null})}t(t){return t.replace(/[\*\_]{2}(.+?)[\*\_]{2}/g,"<strong>$1</strong>").replace(/(?<!\*)_(.+?)_(?!\*)|(?<!\*)\*(.+?)\*(?!\*)/,(t,e,r)=>`<em>${e||r}</em>`).replace(/~~(.+?)~~/g,"<del>$1</del>").replace(/\<([^\s@\>]+@[^\s@\>]+\.[^\s@\>]+)\>/g,'<a href="mailto:$1">$1</a>').replace(/\<((?:https?:\/\/|ftp:\/\/|mailto:|tel:)[^\>\s]+)\>/g,'<a href="$1">$1</a>').replace(/\!\[([^\]]*)\]\(([^\)]+)\)/g,'<img src="$2" alt="$1"/>').replace(/\[([^\]]+)\]\(([^\) ]+)[ ]?(\"[^\)\"]+\")?\)/g,(t,e,r,n)=>`<a href="${r}"${n?" title="+n:""}>${e}</a>`)}l(t){return t.replace(/[&<>"']/g,t=>"&#"+t.charCodeAt(0))}$(t){return t.replace(/<(\/?)\s*(script|iframe|object|embed|frame|link|meta|style|svg|math)[^>]*>/gi,t=>this.l(t)).replace(/\s(?!data-)[\w-]+=\s*["'\s]*(javascript:|data:|expression:)[^"'\s>]*/gi,"").replace(/\<[^\>]+\>/g,t=>t.replace(/\s+on\w+\s*=\s*["']?[^"'\\]*["']?/gi,""))}}"object"==typeof exports&&(module.exports={MiniGFM:MiniGFM});
const md = new MiniGFM();
parsed = '<div>' + md.parse(markdown_text) + '</div>'
var doc = new DOMParser().parseFromString(parsed, "text/html");
document.getElementById("markdown").appendChild(doc.body.firstChild)
</script>
