<!DOCTYPE html>

<!-- In the below script block, write markdown and it will be rendered on the page. -->
<script id="markdown_text" type='text/markdown'>
<hr>
  # Introduction
<hr>

< put stuff here, see course page: https://vanhunteradams.com/Pico/CourseMaterials/Final_Project.html#Final-Report >

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
# High-Level Design
<hr>

< put stuff here, see course page: https://vanhunteradams.com/Pico/CourseMaterials/Final_Project.html#Final-Report >

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
# Hardware Design
<hr>

In order to create a logic analyzer that could accommodate a wide range of digital input signals, three main goals had to be met on the hardware end:
<ul>
- **Requirement 1:** The design needs to be able to accommodate the voltage levels of many common protocols (e.g. 1.8V, 3.3V, 5V) and translate them to 3.3V logic that can be safely input to the RP2350.
- **Requirement 2:** It should be possible to feed in signals on 8+ channels, and the corresponding GPIO pins should be easily accessible.
- **Requirement 3:** The hardware should ideally be able to sample high-frequency signals up to around 100 MHz.
</ul>

To meet all of the above goals, we opted to design a PCB in Altium. The board acts as a 
standalone interface for interacting with the logic analyzer; it contains two 16-pin 
headers, each of which accommodates 8 high-speed digital signals from 1.8V to 5V, GND 
connections, and a signal indicating the voltage level (VCCB). One header feeds into level 
shifter 1 (LS1), which will translate the digital inputs to 3.3V (VCCA) and pass those to 
GPIO8 through GPIO15. The other header feeds into level shifter 2 (LS2), which does the same 
but for GPIO16 through GPIO22 (as well as GPIO26). 

Both level shifters can be enabled by driving GPIO5 and GPIO28 (the designated output-enable 
pins on the RP2350) low. While these level shifters can function bidirectionally, the 
direction (DIR) pins are hardwired to GND using pull-down resistors, strictly enforcing 
voltage translation from the headers pins towards the RP2350.

<div class="row">
  <div class="column">
    <figure>
      <img src="logicanalyzer-layout3D.png" alt="layout3D" style="max-width: 118%; height: auto; display:block; margin:auto;">
      <figcaption>3D view of logic analyzer PCB</figcaption>
    </figure>
  </div>
  <div class="column">
    <figure>
      <img src="logicanalyzer-layout2D.png" alt="layout2D" style="max-width: 120%; height: auto; display:block; margin:auto;">
      <figcaption>Layout of logic analyzer PCB</figcaption>
    </figure>
  </div>
</div> 

<br>

<figure>
  <img src="logicanalyzer-fullschematic.png" alt="fullschematic" style="max-width: 100%; height: auto; display:block; margin:auto;">
  <figcaption>Full schematic of logic analyzer PCB (for higher resolution screenshots, see Appendix C)</figcaption>
</figure>

The level shifters present on our PCB easily accommodate a number of common logic levels 
and are able to pass signals up to 100 MHz, allowing us to emulate the behavior of benchtop 
logic analyzers at a fraction of the cost. Signal integrity is not a major issue here even 
at high-speed, since we were particular about controlling trace width and keeping trace 
lengths to a minimum. Other parts our PCB, like the UART debug header, optional external 
power circuitry, and reset button are other convenience features that further expand 
functionality for the user.

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
# Program Design
<hr>

There are three parts to the software of this project. For our logic analyzer, we created firmware to let the device be
used as a vendor specific USB device, software to connect to the logic analyzer when using this firmware, and firmware
to let the device connect over the serial port to the [PulseView](https://sigrok.org/wiki/PulseView) logic analyzer
software using the [SUMP protocol](https://sump.org/projects/analyzer/protocol/). We will go over each of these sub
projects separatly as follows.

## USB Logic Analyzer
The firmware does not depend on any third party libraries, such as TinyUSB, when interfacing with the USB periferal,
however, it uses siginficant code from the [dev_lowlevel](https://github.com/raspberrypi/pico-examples/tree/4c3a3dc0196dd426fddd709616d0da984e027bab/usb/device/dev_lowlevel)
example for listening and responding to transfers from the USB host. Concretely, use logic from the example to receive
transfers from the host and then call a handler. Our responses are composed of multiple transfers so we wrote a request
queue. This is implemented as a fixed sized FIFO built around a circular buffer. When the logic analyzer needs to send
a sequence of responses, it queues each of these respones in the request queue, starting the first response in the
request queue. Once that response is sent, the program calls a handler which checks if the queue is empty. If it isn't,
the program will send the next request. This repeats until the queue is empty.

The data sent over the USB uses a protocol we created. It is incomplete as we abandoned it to instead use SUMP as
described below. The description of the incomplete protocol follows:

### Protocol Overview
The laft usb application must communicate with the logic analyzer. They do it with the following protocol sent through
USB bulk transfers. The laft application, a usb host, sends requests and the logic analyzer, a usb device, sends
responses. There is no channel for the logic analyzer to make requests of its host. Each request is a 64 bit packet
**starting with a 1 byte opcode**. The rest of request varies between opcodes. The format and size of a response depends
on it's corresponding request. 

### Protocol Opcodes
#### Trace Request
**Request**: |01|XX|SSSS|XXXXXXXX|

This request is used to dump data from every trace attached to the logic analyzer. A trace request starts with a 1 byte
opcode, 0x01. It then follows with a 2 bytes of don't care. It then is a 2 byte little endian integer, the number of
*bits* of data being requested *from each trace*. It then ends with 4 don't care bytes.

**Response**: The response will be a series of 8 byte responses, the raw data form each trace. Bits from each every
trace are packaged into 2 bytes (traces indexed lower being first) and then this packed data is sequenced. It is
sent over 64 bit responses. The final response may be incomplete, in which case the final bytes will be don't cares.

#### Frequency Set Request
**Request**: |02|XXXXXX|FFFFFFFF|

This request sets the frequency the logic analyzer will expect from its traces. A frequency set request starts with a 1
byte opcode, 0x01. It then followed with 3 bytes of don't cares and ends with a 4 byte little endian integer, the
frequency to listen at.

**Response**: The MCU is not expected to respond to this request.

#### Rising Edge Trigger Request
**Request**: |04|X|P|SSSS|XXXXXXXX|

This request request is used to dump data from every trace attached to the logic analyzer starting on a rising edge for
a pin specified by P. This is similar to a trace request, but instead of starting recording at some arbitrary point in
time, it starts on a rising edge. The format is composed of a one byte opcode, followed by a nibble of don't cares and
then a 4 bit number, the pin of the logic analyzer to look for an edge on. This is followed by a little endian two byte
size, the number of bits to record *from each trace*. The request is then padded by four bytes of don't cares.

**Response**: The response is a series of 8 byte responses, the raw data from each trace. It's format is the same as a
Trace Request. Refer there for more details.

<hr>
# Results
<hr>

< put stuff here, see course page: https://vanhunteradams.com/Pico/CourseMaterials/Final_Project.html#Final-Report >

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
# Conclusion
<hr>

< put stuff here, see course page: https://vanhunteradams.com/Pico/CourseMaterials/Final_Project.html#Final-Report>

### Obstacles Faced In Development
AAA
<ul>
- **Hardware Problems**
  <ul>
  - **Short Circuits and Faulty Power-Up:** at some point during the development process, one of the level shifters that was soldered to our PCB experienced internal damage; when 5V signals were then fed into the input pins and the corresponding rail was driven to 5V, lots of odd behavior ensued. The output-enable pin was forced high despite the Pico actively trying to drive the pin low, preventing any signals from being level shifted. Furthermore, the 3.3V rail (connected directly to the Pico) was forced above 4V. This eventually resulted in the Pico failing to power up, breaking all flashing functionality and forcing our team to solder an entirely new PCB.
  - **Fabrication Issues:** when first ordering our boards, we encountered fabrication issues having to do with the open-source Altium footprints we took from Ultra Librarian online. The level shifters in particular had a number of problems with solder pads. On top of the pads for each pin missing soldermask (which caused a hold-up in fabrication on the order of several days), the footprint also contained "ghost pads" which should have never been placed on the board. These were not caught until after boards came in, although these did not prove to be much of an issue as long as caution was taken while soldering.
  </ul>
<br>
<figure>
  <img src="logicanalyzer-faultypad.png" alt="fabrication issue" style="max-width: 40%; height: auto; display:block; margin:auto;">
  <figcaption>Example of a fabrication issue w/ floating pads</figcaption>
</figure>
<br>
- **Software Problems**
  <ul>
  - < List software problems here >
  </ul>
</ul>

<br>
<br>
<br>
  
### Intellectual Property Considerations
< put stuff here, see course page: https://vanhunteradams.com/Pico/CourseMaterials/Final_Project.html#Final-Report>

<br>
<br>
<br>

### Further Improvements
< put stuff here, see course page: https://vanhunteradams.com/Pico/CourseMaterials/Final_Project.html#Final-Report>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

# Appendix
<hr>
### Appendix A - Permissions
<hr>

**Project on Course Page:** The group approves this report for inclusion on the course website.
<br>
**Project on YouTube:** The group did not record a video for inclusion on the course youtube channel.

<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
### Appendix B - Code
<hr>

< insert commented C code here >

<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
### Appendix C - Schematics
<hr>

<figure>
  <img src="logicanalyzer-fullschematic.png" alt="fullschematic" style="max-width: 80%; height: auto; display:block; margin:auto;">
  <figcaption>Full schematic of logic analyzer PCB</figcaption>
</figure>

<br>

<figure>
  <img src="logicanalyzer-RP2350.png" alt="RP2350 circuit" style="max-width: 70%; height: auto; display:block; margin:auto;">
  <figcaption>RP2350 connections for the logic analyzer</figcaption>
</figure>

<br>

<figure>
  <img src="logicanalyzer-levelshifters.png" alt="Level shifter circuit" style="max-width: 70%; height: auto; display:block; margin:auto;">
  <figcaption>Level shifter circuit for the logic analyzer</figcaption>
</figure>

<br>

<figure>
  <img src="logicanalyzer-headers.png" alt="Header circuit" style="max-width: 70%; height: auto; display:block; margin:auto;">
  <figcaption>Headers on the PCB</figcaption>
</figure>

<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
### Appendix D - Task Distribution
<hr>

<ul>
- **Colin Muessig** (cjm369)
  <ul>
  - Designed the PCB used for our logic analyzer in Altium
  - Soldered PCB and debugged faulty behavior; validated logic analyzer at the hardware level (level shifter operation, passage of signals, etc.)
  </ul>
  <br>
  - **Jeremy Ku-Benjet** (jk2582)
  <ul> 
  - < Put work tasks here > 
  </ul>
  <br>
- **Matthew Hurford** (mlh348)
  <ul>
  - < Put work tasks here>
  </ul>
</ul>

<br>
<br>
<br>
<br>
<br>
<br>
<br>

<hr>
### Appendix E - References
<hr>

<ul>
- **Datasheets**
  <ul>
  - [Raspberry Pi Pico 2 Datasheet](https://datasheets.raspberrypi.com/pico/pico-2-datasheet.pdf)
  - [Level Shifter Datasheet](https://www.ti.com/lit/ds/symlink/sn74lvc8t245.pdf?ts=1765867829527)
  </ul>
  <br>
  - **Code / Designs Borrowed From Others**
  <ul>
  - [Level Shifter Altium Footprint](https://app.ultralibrarian.com/details/165e9ff7-103f-11e9-ab3a-0a3560a4cccc/Texas-Instruments/SN74LVC8T245DBR?uid=668960&exports=41&open=exports)
  - [Raspberry Pi Pico 2 Altium Footprint](https://github.com/amgsus/RPi-Pico-Altium)
  - [16-Pin Header Altium Footprint](https://app.ultralibrarian.com/details/edb9d735-103e-11e9-ab3a-0a3560a4cccc/TE-Connectivity/5102153-3?uid=39437029)
  - [3-Pin Header Altium Footprint](https://app.ultralibrarian.com/details/425a797b-1081-11e9-ab3a-0a3560a4cccc/Samtec-Inc/TSW-103-15-T-S?uid=12085636)
  - [2-Pin Header Altium Footprint](https://app.ultralibrarian.com/details/42530aaf-1081-11e9-ab3a-0a3560a4cccc/Samtec-Inc/TSW-102-06-S-S?uid=271997)
  </ul>
  <br>
- **Background Sites / Papers**
  <ul>
  - < insert any relevant links here >
  </ul>
  <br>
</ul>

<br>
<br>
<br>

</script>

<head>
    <link rel="stylesheet" href="template.css" type="text/css">
    <link rel="icon" href="favicon.ico">
</head>
<body>
    </div>
    <div id="main">
        <div id="title_block">
          <h1>LAFT Logic Analyzer</h1>
          <h2>ECE 4760/5730 Final Project</h2>
          <br>
          <div class="subtitle">
            Colin Muessig (cjm369) · Jeremy Ku-Benjet (jk2582) · Matthew Hurford (mlh348)
          </div>
          <br>
          <figure>
            <img src="BuddyCombo.png" alt="Project mascot (dog)" style="max-width: 70%; height: auto; display:block; margin:auto;">
          </figure>
          <figcaption class="photo_caption">Buddy — Chief Debugging Officer</figcaption>
    </div>
        <fieldset id="markdown">
        </fieldset>
    </div>
</body>
<script>
markdown_text = document.getElementById("markdown_text").textContent

//   MIT License
// 
// Copyright (c) 2025 Fgaoxing
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
class MiniGFM{constructor(t){this.options=t||{}}parse(t){if("string"!=typeof t)return"";let s=[],n=[];return t=this.t(this.i(t.replace(/(?:^|\n)[^\\]?(`{3,4})[ ]*(\w*?)\n([\s\S]*?)\n\1/g,(t,e,r,n)=>(s.push({lang:r.trim(),code:n.trim()}),`<!----CODEBLOCK${s.length-1}---->`)).replace(/([^\\])`([^`]+)`/g,(t,e,r)=>(n.push(this.l(r)),`${e}<!----CODEINLINE${n.length-1}---->`)).replace(/\\([\\*_{}[\]()#+\-.!`])/g,(t,e)=>"&#"+e.charCodeAt(0)).replace(/%%[\n ][^%]+[\n ]%%/g,""))).replace(/<!----CODEINLINE(\d+)---->/g,(t,e)=>n[e]?`<code>${n[e]}</code>`:"").replace(/<!----CODEBLOCK(\d+)---->/g,(t,e)=>{if(!s[e])return"";var{lang:e,code:r}=s[e];let n=r;if(this.options.hljs)try{n=(e?this.options.hljs.highlight(r,{language:e}):this.options.hljs.highlightAuto(r)).value}catch{}return e?`<pre lang="${e}"><code class="hljs ${e} lang-${e}">${n}</code></pre>`:`<pre><code>${n}</code></pre>`}),this.options.unsafe?t:this.$(t)}i(t){return t.replace(/^[^\\]?\s*(#{1,6}) ([^\n]+)$/gm,(t,e,r)=>`<h${e.length}>${r}</h${e.length}>`).replace(/^[ \t]*[-\*\+][ \t]+\[([ ]*[ xX]?)\]\s([^\n]+)$/gm,(t,e,r)=>`<li><input type="checkbox" ${"x"===e.trim().toLowerCase()?"checked":""} disabled> ${r}</li>`).replace(/^[ \t]*[-\*\+] ([^\n]+)$/gm,"<li>$1</li>").replace(/^[ \t]*(\d+\.) ([^\n]+)$/gm,"<li>$1 $2</li>").replace(/^ {0,3}(([*_-])( *\2 *){2,})(?:\s*$|$)/gm,()=>"<hr/>").replace(/^[ \t]*((?:\>[ \t]*)+)([^\n]*)$/gm,(t,e,r)=>{e=e.length/2;return""===r.trim()?"":"<blockquote>".repeat(e)+r+"</blockquote>".repeat(e)}).replace(/^([^\n]*\|[^\n]*)\n([-:| ]+\|)+[-\| ]*\n((?:[^\n]*\|[^\n]*(?:\n|$))*)/gm,(t,e,r,n)=>this.g(e,r,n)).split(/\n{2,}|\\\n/g).map(t=>/^<(\w+)/.test(t)?t:`<p>${t}</p>`).join("<br />")}g(t,e,r){let n=t.split("|").map(t=>t.trim()).filter(Boolean),s=this.o(e);t=r.trim().split("\n").reduce((t,e)=>{if(e.includes("|")){let r=e.split("|").slice(1,-1).map(t=>t.trim());t.push(n.map((t,e)=>r[e]||""))}return t},[]);let a=["<table>","<thead><tr>"];return n.forEach((t,e)=>{a.push(`<th${s[e]?` align="${s[e]}"`:""}>${t}</th>`)}),a.push("</tr></thead>"),t.length&&(a.push("<tbody>"),t.forEach(t=>{a.push("<tr>",...t.map((t,e)=>`<td${s[e]?` align="${s[e]}"`:""}>${t}</td>`),"</tr>")}),a.push("</tbody>")),[...a,"</table>"].join("")}o(t){return t.split("|").map(t=>t.trim()).filter(Boolean).map(t=>{var e=t.startsWith(":"),t=t.endsWith(":");return e&&t?"center":e?"left":t?"right":null})}t(t){return t.replace(/[\*\_]{2}(.+?)[\*\_]{2}/g,"<strong>$1</strong>").replace(/(?<!\*)_(.+?)_(?!\*)|(?<!\*)\*(.+?)\*(?!\*)/,(t,e,r)=>`<em>${e||r}</em>`).replace(/~~(.+?)~~/g,"<del>$1</del>").replace(/\<([^\s@\>]+@[^\s@\>]+\.[^\s@\>]+)\>/g,'<a href="mailto:$1">$1</a>').replace(/\<((?:https?:\/\/|ftp:\/\/|mailto:|tel:)[^\>\s]+)\>/g,'<a href="$1">$1</a>').replace(/\!\[([^\]]*)\]\(([^\)]+)\)/g,'<img src="$2" alt="$1"/>').replace(/\[([^\]]+)\]\(([^\) ]+)[ ]?(\"[^\)\"]+\")?\)/g,(t,e,r,n)=>`<a href="${r}"${n?" title="+n:""}>${e}</a>`)}l(t){return t.replace(/[&<>"']/g,t=>"&#"+t.charCodeAt(0))}$(t){return t.replace(/<(\/?)\s*(script|iframe|object|embed|frame|link|meta|style|svg|math)[^>]*>/gi,t=>this.l(t)).replace(/\s(?!data-)[\w-]+=\s*["'\s]*(javascript:|data:|expression:)[^"'\s>]*/gi,"").replace(/\<[^\>]+\>/g,t=>t.replace(/\s+on\w+\s*=\s*["']?[^"'\\]*["']?/gi,""))}}"object"==typeof exports&&(module.exports={MiniGFM:MiniGFM});
const md = new MiniGFM();
parsed = '<div>' + md.parse(markdown_text) + '</div>'
var doc = new DOMParser().parseFromString(parsed, "text/html");
document.getElementById("markdown").appendChild(doc.body.firstChild)
</script>
